from re import *


def infix_to_prefix(raw_text):

	raw_text = raw_text[::-1]
	text = ''

	for letter in raw_text:
		if letter == '(':
			text = text + ')'
		elif letter == ')':
			text = text + '('
		else:
			text = text + letter
	
	stack = []
	postfix = ''

	i = 0
	while(i < len(text)):
		letter = text[i]

		if letter == '(':
			stack.append('(')
			postfix = postfix + ')'
		elif letter == ')':
			x = stack.pop()
			while(x != '('):
				postfix = postfix + x
				x = stack.pop()
			postfix = postfix + '('
		elif letter == '|':
			postfix = postfix + ','
			if stack == []:
				stack.append(' rO')
				i+=1
			else:
				x = stack.pop()
				while(x != '('):
					postfix = postfix + x
					x = stack.pop()
				stack.append('(')
				stack.append(' rO')
				i+=1

		elif letter == '&':
			postfix = postfix + ','
			if stack == []:
				stack.append(' dnA')
				i+=1
			else:
				x = stack.pop()
				while(x != '('):
					postfix = postfix + x
					x = stack.pop()
				stack.append('(')
				stack.append(' dnA')
				i+=1

		else:
			postfix = postfix + letter 

		i+=1

	while(stack != []):
		x = stack.pop()
		postfix = postfix + x

	prefix = postfix[::-1]
	prefix = sub('\(Or ','Or(', prefix)
	prefix = sub('\(And ','And(', prefix)
	
	
	#Also have to return the set of conditions
	arr = prefix.split(',')
	arr = [sub('And|Or|\(|\)|','',cond) for cond in arr]
	arr = [cond.strip() for cond in arr]		
	return (prefix,arr)


def Tarjan(vertices,edges):
	
	index = 0
	stack = []
	arr_index = [-1 for vertex in vertices]
	low_link = [len(vertices)+1 for vertex in vertices]
	on_stack = [False for vertex in vertices]
	SCCs = []

	def strong_connect(v,index):
		vertex = vertices[v]

		arr_index[v] = index
		low_link[v] = index
		index+=1
		stack.append(v)
		on_stack[v] = True

		for w in range(len(vertices)):
			incoming = vertices[w]
			if [vertex,incoming] not in edges:
				continue
			
			if arr_index[w] == -1:
				strong_connect(w,index)
				low_link[v] = min(low_link[v],low_link[w])

			elif on_stack[w]:
				low_link[v] = min(low_link[v],arr_index[w])

		
		

		if low_link[v] == arr_index[v]:
			scc = []
			w = -1
			while(w != v):
				w = stack.pop()
				on_stack[w] = False
				scc.append(vertices[w])
			SCCs.append(scc[:])
		return index
			

	for i in range(len(vertices)):
		vertex = vertices[i]
		if arr_index[i] == -1:
			index = strong_connect(i,index)

			
	
	return SCCs



def aut_master(lines):
		
	lines = lines[2:]
	lines = [line[:-1] for line in lines] #Removing the newline
	
	def func(arr,j):
		res = []
		i = j
		for elem in arr[j:]:
			if elem != '}':
				if elem[-1] == ';':
					elem = elem[:-1]
				res.append(elem) #Skipping the semicolon 
				i+=1
			else:
				i+=3 #Skipping the new line and the additional string at the start of the next module
				break
		return (res,i)
			


	#Getting shared variables

	
	shared = lines[0].split(' ')[1:] #Removing the initial string 'shared'
	shared = [var[:-1] for var in shared] #Removing the commas and semi-colons

	parameters = lines[1].split(' ')[1:]
	parameters = [parameter[:-1] for parameter in parameters]

	(assumptions, next_line) = func(lines,3)

	(locations,next_line) = func(lines, next_line)
	locations = [location.split(':')[0] for location in locations]

	(inits,next_line) = func(lines, next_line)
	
	number_function = inits[0].split('== ')[1]

	(unformatted_rules,next_line) = func(lines, next_line)


	#print(shared)
	#print(parameters)
	#print(assumptions)
	#print(locations)
	#print(inits)
	#print(number_function)
	#print(unformatted_rules)


	rules = []
	all_conditions = set()
	fall_conditions = set()	
	all_edges = []
	count = 0

	for x in range(0,len(unformatted_rules),3):
		unformatted_edge = unformatted_rules[x].split(': ')[1]
		edge = unformatted_edge.split(' -> ')

		all_edges.append(edge)

		unformatted_condition = unformatted_rules[x+1].split('when ')[1]
		if unformatted_condition == '(1)' or unformatted_condition == '(true)':
			unformatted_condition = '(True)'
		
		condition,arr = infix_to_prefix(unformatted_condition)
		for cond in arr:
			all_conditions.add(cond)
			if '<' in cond:
				fall_conditions.add(cond)

		unformatted_update = unformatted_rules[x+2].split('do ')[1]
		unformatted_update = sub(' }|{ |\(|\)|unchanged','',unformatted_update)
		unformatted_update = sub(';',',',unformatted_update)
		unformatted_update = unformatted_update.split(', ')
		update = [sub('[a-z,A-Z,0-9].*\ == ','',z) for z in unformatted_update]
		update = [sub('\ |,','',z) for z in update]
		
		rules.append((edge, condition, arr, update, count))
		count+=1

	num_conditions = len(all_conditions)
	num_rules = len(rules)


	#Do Tarjan and identify all the sccs

	SCCs = Tarjan(locations,all_edges)
	
	cycles = [] #Assuming that the graph contains only simple cycles. Hence a SCC is just a cycle
	for scc in SCCs:
		cycle = []
		for rule in rules:
			edge = rule[0]
			rule_no = rule[4]
			if edge[0] in scc and edge[1] in scc:
				cycle.append(rule_no)
		if cycle != []:
			cycles.append(cycle)	


	print ('Finished preprocessing the automaton')


	return(shared, parameters, assumptions, locations, number_function, inits, rules, all_conditions, fall_conditions, num_rules, num_conditions, cycles, SCCs)







def optimizations(locations, inits, rules, targets):

	sinks = set()
	for loc in locations:
		source = True
		for rule in rules:
			if rule[0][0] == loc:
				source = False
				break
		if source == True:
			sinks.add(loc)



	fl = 0
	for sink in sinks:
		if sink in targets:
			continue
		fl = 1
		locations.remove(sink)
		x = sink + ' == 0'
		inits.remove(x)

	if fl == 1:
		locations.append('loc_sink')
		inits.append('loc_sink == 0')

		for rule in rules:
			if rule[0][1] in sinks and rule[0][1] not in targets:
				rule[0][1] = 'loc_sink'



	num_rules = len(rules)
	

	sim = set()
	vertices = set()
	fl = 0

	while fl == 0:
		fl = 1

		for x in locations:
			for y in locations:

				if (x,y) in sim:
					continue
				if x == y or y == 'loc_sink' or x == 'loc_sink':
					continue
			
				xrules = []
				yrules = []
				for rule in rules:
					if rule[0][0] == x:
						xrules.append(rule)
					if rule[0][0] == y:
						yrules.append(rule)


				flagx = 1
				for xrule in xrules:
					flag_xrule = 1
					for yrule in yrules:
						if yrule[0][1] != xrule[0][1] and (xrule[0][1],yrule[0][1]) not in sim:
							continue
						elif yrule[1] != xrule[1] or yrule[3] != xrule[3]:
							continue
						else:
							flag_xrule = 0
							break
					if flag_xrule == 1:
						flagx = 0
						break

				
				if flagx == 0:
					continue


				flagy = 1
				for yrule in yrules:
					flag_yrule = 1
					for xrule in xrules:
						if yrule[0][1] != xrule[0][1] and (xrule[0][1],yrule[0][1]) not in sim:
							continue
						elif yrule[1] != xrule[1] or yrule[3] != xrule[3]:
							continue
						else:
							flag_yrule = 0
							break
					if flag_yrule == 1:
						flagy = 0
						break
	
				
				if flagy == 0:
					continue


				sim.add((x,y))
				sim.add((y,x))
				vertices.add(x)
				vertices.add(y)
				fl = 0


	arcs = [[x,y] for (x,y) in sim]
	sccs = Tarjan(list(vertices),arcs)
	
	for i in range(len(sccs)):
		scc = sccs[i]	
		
		fl = 0
		for vertex in scc:
			if vertex in targets:
				continue
			
			fl = 1
			locations.remove(vertex)
			inits.remove(vertex + ' == 0')

			
		if fl == 0:
			continue
	
		locations.append('loc_'+str(i))
		inits.append('loc_'+str(i)+' == 0')

		for rule in rules:
			if rule[0][0] in scc and rule[0][0] not in targets:
				rule[0][0] = 'loc_'+str(i)
			if rule[0][1] in scc and rule[0][1] not in targets:
				rule[0][1] = 'loc_'+str(i)
	

	
	new_rules = []
	red_new_rules = []
	count = 0
	for rule in rules:
		if rule[0][0] == rule[0][1]:
			continue
		if rule[:-1] in red_new_rules:
			continue
		red_new_rules.append(rule[:-1])
		new_rules.append((rule[0],rule[1],rule[2],rule[3],count))
		count+=1
		
	rules = new_rules
	num_rules = len(rules)


	print ('Performed optimizations for the current specification and the automaton')

	for rule in rules:
		edge = rule[0]
		assert edge[0] != edge[1]

	return (locations, inits, rules, num_rules)











files = []

#files = ['aba_manual', 'bosco_manual', 'c1cs_manual', 'cbc_manual', 'cf1s_manual', 'frb_manual', 'nbacg_manual', 'nbacr_manual', 'strb_manual'] #['frb','strb','nbacg','aba_CASE1','aba_CASE2','cbc_CASE1', 'cbc_CASE2', 
#'cf1s_CASE1','cf1s_CASE2','cf1s_CASE3','c1cs_CASE1','c1cs_CASE2','c1cs_CASE3'] 


for fi in files:
	f = open(fi,'r')
	lines = f.readlines()
	shared, parameters, assumptions, locations, number_function, inits, rules, all_conditions, fall_conditions, num_rules, num_conditions, cycles, SCCs = aut_master(lines)

	print ('File: ' + fi)
	print ('\nGuards: ')
	for cond in all_conditions:
		print (cond)
	
	print ('\nResilience conditions:) '
	for cond in assumptions:
		print (cond)	

	print ('\nCycles: ')
	for cycle in cycles:
		if len(cycle) > 1:
			print (cycle)



	print ('\n')






def compute_depth():
	visited = []
	depth = {}



	fl = 0
	while fl == 0:
		fl = 1
		for loc in locations:
			if loc in visited:
				continue
			source = True
			for rule in rules:
				if rule[0][1] == loc:
					if rule[0][0] not in visited:
						source = False
						break
			if source == True:
				fl = 0
				visited.append(loc)
				dep = 0
				for rule in rules:
					if rule[0][1] == loc:
						dep = max(dep,depth[rule[0][0]]+1)
				depth[loc] = dep


	max_depth = 0
	for loc in locations:
		if loc in depth.keys():
			max_depth = max(max_depth,depth[loc])

	print(max_depth)

