skel Proc {
local pc;
shared nsntEC, nsntRD;
parameters N, T, F;
assumptions (0) {
N > 3 * T;
T >= F;
T >= 1;
}

locations (0) {
loc0: [0]; 
loc1: [1]; 
locEC: [2]; 
locRD: [3]; 
locAC: [4];
}

inits (0) {
(loc0 + loc1) == N - F;
locEC == 0;
locRD == 0;
locAC == 0;
nsntEC == 0;
nsntRD == 0;
}

rules (10) {
0: loc1 -> locEC
when (true)
do { nsntEC' == nsntEC + 1; nsntRD' == nsntRD; };
1: loc0 -> locEC
when (2 * nsntEC >= N + T + 1 - 2 * F) 
do { nsntEC' == nsntEC + 1; nsntRD' == nsntRD; };
2: loc0 -> locEC
when (nsntRD >= T + 1 - F)
do { nsntEC' == nsntEC + 1; nsntRD' == nsntRD; };
3: locEC -> locRD
when (2 * nsntEC >= N + T + 1 - 2 * F) 
do { nsntEC' == nsntEC; nsntRD' == nsntRD + 1; };
4: locEC -> locRD
when (nsntRD >= T + 1 - F)
do { nsntEC' == nsntEC; nsntRD' == nsntRD + 1; };
5: locRD -> locAC
when (2 * nsntRD >= 2 * T + 1)
do { unchanged(nsntEC, nsntRD); };
6: loc0 -> loc0
when (2 * nsntEC < N + T + 1 && nsntRD < T + 1)
do { unchanged(nsntEC, nsntRD); };
7: locEC -> locEC
when (2 * nsntEC < N + T + 1 && nsntRD < T + 1)
do { unchanged(nsntEC, nsntRD); };
8: locRD -> locRD
when (nsntRD < 2 * T + 1)
do { unchanged(nsntEC, nsntRD); };
9: locAC -> locAC
when (true)
do { unchanged(nsntEC, nsntRD); };
}

